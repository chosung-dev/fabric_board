{
  "_args": [
    [
      "release-zalgo@1.0.0",
      "/usr/src/npm/nyc"
    ]
  ],
  "_from": "release-zalgo@1.0.0",
  "_id": "release-zalgo@1.0.0",
  "_inBundle": false,
  "_integrity": "sha1-CXALflB0Mpc5Mw5TXFqQ+2eFFzA=",
  "_location": "/nyc/release-zalgo",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "release-zalgo",
    "fetchSpec": "1.0.0",
    "name": "release-zalgo",
    "raw": "release-zalgo@1.0.0",
    "rawSpec": "1.0.0",
    "registry": true,
    "saveSpec": null,
    "type": "version"
  },
  "_requiredBy": [
    "/nyc/package-hash"
  ],
  "_resolved": "https://registry.npmjs.org/release-zalgo/-/release-zalgo-1.0.0.tgz",
  "_shrinkwrap": null,
  "_spec": "1.0.0",
  "_where": "/usr/src/npm/nyc",
  "author": {
    "name": "Mark Wubben",
    "url": "https://novemberborn.net/"
  },
  "bugs": {
    "url": "https://github.com/novemberborn/release-zalgo/issues"
  },
  "dependencies": {
    "es6-error": "^4.0.1"
  },
  "description": "Helps you write code with promise-like chains that can run both synchronously and asynchronously",
  "devDependencies": {
    "@novemberborn/as-i-preach": "^7.0.0",
    "ava": "^0.18.0",
    "coveralls": "^2.11.15",
    "nyc": "^10.1.2"
  },
  "engines": {
    "node": ">=4"
  },
  "files": [
    "index.js",
    "lib"
  ],
  "homepage": "https://github.com/novemberborn/release-zalgo#readme",
  "keywords": [
    "babel"
  ],
  "license": "ISC",
  "main": "index.js",
  "name": "release-zalgo",
  "nyc": {
    "reporter": [
      "html",
      "lcov",
      "text"
    ]
  },
  "optionalDependencies": {},
  "readme": "# release-zalgo\n\nHelps you write code with promise-like chains that can run both synchronously\nand asynchronously.\n\n## Installation\n\n```console\n$ npm install --save release-zalgo\n```\n\n## Usage\n\nIf you use this module, you'll release **Ẕ̶̨̫̹̌͊͌͑͊̕͢͟a̡̜̦̝͓͇͗̉̆̂͋̏͗̍ͅl̡̛̝͍̅͆̎̊̇̕͜͢ģ̧̧͍͓̜̲͖̹̂͋̆̃̑͗̋͌̊̏ͅǫ̷̧͓̣͚̞̣̋̂̑̊̂̀̿̀̚͟͠ͅ**. You mustn't do that.\n\nBefore you proceed, please read this great post by [Isaac\nSchlueter](http://izs.me/) on [Designing APIs for\nAsynchrony](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).\n\nThe first rule of using this package is to keep your external API consistent.\n\nThe second rule is to accept the burden of controlling Ẕ̶̨̫̹̌͊͌͑͊̕͢͟a̡̜̦̝͓͇͗̉̆̂͋̏͗̍ͅl̡̛̝͍̅͆̎̊̇̕͜͢ģ̧̧͍͓̜̲͖̹̂͋̆̃̑͗̋͌̊̏ͅǫ̷̧͓̣͚̞̣̋̂̑̊̂̀̿̀̚͟͠ͅ by ensuring he does not escape your API boundary.\n\nWith that out of the way… this package lets you write code that can run both\nsynchronously and asynchronously. This is useful if you have fairly complex\nlogic for which you don't want to write multiple implementations. See\n[`package-hash`](https://github.com/novemberborn/package-hash) for instance.\n\nThis is best shown by example. Let's say you have a `hashFile()` function:\n\n```js\nconst crypto = require('crypto')\nconst fs = require('fs')\n\nfunction hashFile (file) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(file, (err, buffer) => err ? reject(err) : resolve(buffer))\n  })\n    .then(buffer => {\n      const hash = crypto.createHash('sha1')\n      hash.update(buffer)\n      return hash.digest('hex')\n    })\n}\n```\n\nA synchronous version could be implemented like this:\n\n```js\nfunction hashFileSync (file) {\n  const buffer = fs.readFileSync(file)\n  const hash = crypto.createHash('sha1')\n  hash.update(buffer)\n  return hash.digest('hex')\n}\n```\n\nHere's the version that uses `release-zalgo`:\n\n```js\nconst crypto = require('crypto')\nconst fs = require('fs')\n\nconst releaseZalgo = require('release-zalgo')\n\nconst readFile = {\n  async (file) {\n    return new Promise((resolve, reject) => {\n      fs.readFile(file, (err, buffer) => err ? reject(err) : resolve(buffer))\n    })\n  },\n\n  sync (file) {\n    return fs.readFileSync(file)\n  }\n}\n\nfunction run (zalgo, file) {\n  return zalgo.run(readFile, file)\n    .then(buffer => {\n      const hash = crypto.createHash('sha1')\n      hash.update(buffer)\n      return hash.digest('hex')\n    })\n}\n\nfunction hashFile (file) {\n  return run(releaseZalgo.async(), file)\n}\n\nfunction hashFileSync (file) {\n  const result = run(releaseZalgo.sync(), file)\n  return releaseZalgo.unwrapSync(result)\n}\n```\n\nNote how close the `run()` implementation is to the original `hashFile()`.\n\nJust don't do this:\n\n```js\nfunction badExample (zalgo, file) {\n  let buffer\n  zalgo.run(readFile, file)\n    .then(result => { buffer = result })\n\n  const hash = crypto.createHash('sha1')\n  hash.update(buffer)\n  return hash.digest('hex')\n}\n```\n\nThis won't work asynchronously. Just pretend you're working with promises and\nyou'll be OK.\n\n## API\n\nFirst require the package:\n\n```js\nconst releaseZalgo = require('release-zalgo')\n```\n\n### `releaseZalgo.sync()`\n\nReturns a `zalgo` object that runs code synchronously:\n\n```js\nconst zalgo = releaseZalgo.sync()\n```\n\n### `releaseZalgo.async()`\n\nReturns a `zalgo` object that runs code asynchronously:\n\n```js\nconst zalgo = releaseZalgo.async()\n```\n\n### `releaseZalgo.unwrapSync(thenable)`\n\nSynchronously unwraps a [thenable], which is returned when running\nsynchronously. Returns the [thenable]s fulfilment value, or throws its\nrejection reason. Throws if the [thenable] is asynchronous.\n\n### `zalgo.run(executors, ...args)`\n\nWhen running synchronously, `executors.sync()` is called. When running\nasynchronously `executors.async()` is used. The executer is invoked immediately\nand passed the remaining arguments.\n\nFor asynchronous execution a `Promise` is returned. It is fulfilled with\n`executors.async()`'s return value, or rejected if `executors.async()` throws.\n\nFor synchronous execution a *[thenable]* is returned. It has the same methods as\n`Promise` except that callbacks are invoked immediately. The [thenable] is\nfulfilled with `executors.sync()`'s return value, or rejected if\n`executors.sync()` throws.\n\n### `zalgo.all(arr)`\n\nWhen running synchronously, returns a new [thenable] which is fulfilled with\nan array, after unwrapping all items in `arr`.\n\nWhen running asynchronously, delegates to `Promise.all(arr)`.\n\n### `zalgo.returns(value)`\n\nWhen running synchronously, returns a new [thenable] which is fulfilled with\n`value`.\n\nWhen running asynchronously, delegates to `Promise.resolve(value)`.\n\n### `zalgo.throws(reason)`\n\nWhen running synchronously, returns a new [thenable] which is rejected with\n`reason`.\n\nWhen running asynchronously, delegates to `Promise.reject(reason)`.\n\n### Thenables\n\nThenables are returned when running sychronously. They're much like `Promise`s,\nin that they have `then()` and `catch()` methods. You can pass callbacks and\nthey'll be invoked with the fulfilment value or rejection reason. Callbacks\ncan return other thenables or throw exceptions.\n\nNote that `then()` and `catch()` must be called on the thenable, e.g.\n`thenable.then()`, not `(thenable.then)()`.\n\nThenables should not be exposed outside of your API. Use\n`releaseZalgo.unwrapSync()` to unwrap them.\n\n[thenable]: #thenables\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/novemberborn/release-zalgo.git"
  },
  "scripts": {
    "coverage": "nyc npm test",
    "lint": "as-i-preach",
    "posttest": "as-i-preach",
    "test": "ava"
  },
  "standard-engine": "@novemberborn/as-i-preach",
  "version": "1.0.0"
}
